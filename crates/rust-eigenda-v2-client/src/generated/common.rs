// This file is @generated by prost-build.
/// G1Commitment represents the serialized coordinates of a G1 KZG commitment.
/// We use gnark-crypto so adopt its serialization, which is big-endian. See:
/// <https://github.com/Consensys/gnark-crypto/blob/779e884dabb38b92e677f4891286637a3d2e5734/ecc/bn254/fp/element.go#L862>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct G1Commitment {
    /// The X coordinate of the KZG commitment. This is the raw byte representation of the field element.
    /// Should contain 32 bytes.
    #[prost(bytes = "vec", tag = "1")]
    pub x: ::prost::alloc::vec::Vec<u8>,
    /// The Y coordinate of the KZG commitment. This is the raw byte representation of the field element.
    /// Should contain 32 bytes.
    #[prost(bytes = "vec", tag = "2")]
    pub y: ::prost::alloc::vec::Vec<u8>,
}
/// BlobCommitment represents commitment of a specific blob, containing its
/// KZG commitment, degree proof, the actual degree, and data length in number of symbols (field elements).
/// It deserializes into <https://github.com/Layr-Labs/eigenda/blob/ce89dab18d2f8f55004002e17dd3a18529277845/encoding/data.go#L27>
///
/// See <https://github.com/Layr-Labs/eigenda/blob/e86fb8515eb606d0eebb92097dc60d7238363e77/docs/spec/src/protocol/architecture/encoding.md#validation-via-kzg>
/// to understand how this commitment is used to validate the blob.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobCommitment {
    /// Concatenation of the x and y coordinates of `common.G1Commitment`.
    #[prost(bytes = "vec", tag = "1")]
    pub commitment: ::prost::alloc::vec::Vec<u8>,
    /// A commitment to the blob data with G2 SRS, used to work with length_proof
    /// such that the claimed length below is verifiable.
    #[prost(bytes = "vec", tag = "2")]
    pub length_commitment: ::prost::alloc::vec::Vec<u8>,
    /// A proof that the degree of the polynomial used to generate the blob commitment is valid.
    /// It consists of the KZG commitment of x^(SRSOrder-n) * P(x), where
    /// P(x) is polynomial of degree n representing the blob.
    #[prost(bytes = "vec", tag = "3")]
    pub length_proof: ::prost::alloc::vec::Vec<u8>,
    /// The length of the blob in symbols (field elements), which must be a power of 2.
    /// This also specifies the degree of the polynomial used to generate the blob commitment,
    /// since length = degree + 1.
    #[prost(uint32, tag = "4")]
    pub length: u32,
}
